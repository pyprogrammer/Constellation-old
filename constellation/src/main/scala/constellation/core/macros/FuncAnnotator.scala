package constellation.core.macros

import scala.reflect.macros.whitebox

object FuncAnnotator {
  var funcCounter = 0

  def createAnnotator(c: whitebox.Context): c.universe.Transformer = {
    import c.universe._
    object FuncTransformer extends Transformer {
      override def transform(tree: c.universe.Tree): c.universe.Tree = {
        val newTree = super.transform(tree)
        newTree match {
          case (functionDef@q"(..$params) => $expr") =>
            println(functionDef)
            println(showRaw(functionDef))
            println(functionDef.tpe)
            val name = c.universe.TermName(s"__constellation_core_macros_FuncAnnotator_generatedFunction$funcCounter")
            funcCounter += 1

            val typeSignature = functionDef.tpe.asInstanceOf[TypeRefApi].typeArgs
            val paramTypes = typeSignature.init
            val returnType = typeSignature.last

            val applyArgs = paramTypes.zipWithIndex.map({
              d => s"x${d._2}: ${d._1}"
            }).mkString(", ")

            val applyParams = paramTypes.zipWithIndex.map({
              d => s"x${d._2}"
            }).mkString(", ")

            val applyDef = c.parse(
              s"def apply($applyArgs): $returnType = func($applyParams)"
            )

            val functionDefString = functionDef.toString()

            val function =
              q"""
                 object $name extends ${functionDef.tpe} with Serializable with constellation.core.macros.AnnotatedFunction {
                    val func: ${functionDef.tpe} = ((..$params) => $expr)
                    override def toString: String = s"<AutoGeneratedFunction: $$funcString>"
                    val funcString: String = $functionDefString
                    $applyDef
                 }
               """
            println(function)
            q"""
               {
                $function
                $name
               }
             """

          case _ => newTree
        }
      }
    }
    FuncTransformer
  }
}
